https://blog.openshift.com/day-20-stanford-corenlp-performing-sentiment-analysis-of-twitter-using-java/

public static HashSet<String>	negator;

	public static HashSet<String>	positiveSentiDic;

	public static HashSet<String>	negativeSentiDic;

	public static String			negatorPath			= ParamConfiguration.getInstance()
																.getNEGATOR_PATH();

	public static String			poistiveSentiPath	= ParamConfiguration
																.getInstance()
																.getPOSITIVE_WORDS_PATH();

	public static String			negativeSentiPath	= ParamConfiguration
																.getInstance()
		
																.getNEGATIVE_WORDS_PATH();
	static StanfordCoreNLP pipeline ;

	static {
		  
		Properties props = new Properties();
		props.setProperty("annotators", "tokenize, ssplit,pos");
		pipeline = new StanfordCoreNLP(props);

		negator = FileUtils.convertTextToHashSet( negatorPath);
		positiveSentiDic = FileUtils
				.convertTextToHashSet(poistiveSentiPath);
		negativeSentiDic = FileUtils
				.convertTextToHashSet(negativeSentiPath);
	}





-------------------------------------------------------
public TweetWithSentiment findSentiment(String line) {
 
        Properties props = new Properties();
        props.setProperty("annotators", "tokenize, ssplit, parse, sentiment");
        StanfordCoreNLP pipeline = new StanfordCoreNLP(props);
        int mainSentiment = 0;
        if (line != null && line.length() > 0) {
            int longest = 0;
            Annotation annotation = pipeline.process(line);
            for (CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {
                Tree tree = sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);
                int sentiment = RNNCoreAnnotations.getPredictedClass(tree);
                String partText = sentence.toString();
                if (partText.length() > longest) {
                    mainSentiment = sentiment;
                    longest = partText.length();
                }
 
            }
        }
        if (mainSentiment == 2 || mainSentiment > 4 || mainSentiment < 0) {
            return null;
        }
        TweetWithSentiment tweetWithSentiment = new TweetWithSentiment(line, toCss(mainSentiment));
        return tweetWithSentiment;
 
    }
    ----------------------------------------------------------------
    
    
     public List<Status> search(String keyword) {
        ConfigurationBuilder cb = new ConfigurationBuilder();
        cb.setDebugEnabled(true).setOAuthConsumerKey(System.getenv("TWITTER_OAUTH_CONSUMER_KEY"))
                .setOAuthConsumerSecret(System.getenv("TWITTER_OAUTH_CONSUMER_SECRET"))
                .setOAuthAccessToken(System.getenv("TWITTER_OAUTH_ACCESS_TOKEN"))
                .setOAuthAccessTokenSecret(System.getenv("TWITTER_OAUTH_ACCESS_TOKEN_SECRET"));
        TwitterFactory tf = new TwitterFactory(cb.build());
        Twitter twitter = tf.getInstance();
        Query query = new Query(keyword + " -filter:retweets -filter:links -filter:replies -filter:images");
        query.setCount(20);
        query.setLocale("en");
        query.setLang("en");;
        try {
            QueryResult queryResult = twitter.search(query);
            return queryResult.getTweets();
        } catch (TwitterException e) {
            // ignore
            e.printStackTrace();
        }
        return Collections.emptyList();
 
    }
 
    
    
    
    -------------------------------------------------------------------
    public static boolean matchPosTag(final String tag) {

		if (tag.equalsIgnoreCase("NN") || tag.equalsIgnoreCase("NNS")
				|| tag.equalsIgnoreCase("NNP") || tag.equalsIgnoreCase("NNS")
				|| tag.equalsIgnoreCase("JJ") || tag.equalsIgnoreCase("JJR")
				|| tag.equalsIgnoreCase("JJS") || tag.equalsIgnoreCase("VB")
				|| tag.equalsIgnoreCase("VBD") || tag.equalsIgnoreCase("VBN")
				|| tag.equalsIgnoreCase("VBG") || tag.equalsIgnoreCase("VBZ")
				|| tag.equalsIgnoreCase("RB") || tag.equalsIgnoreCase("RBR")
				|| tag.equalsIgnoreCase("RBS")) {

			return true;

		}
		return false;
	}

	public static String matchNegators(final List<String> tokenStr,
			final HashSet<String> negators) {

		for (String word : tokenStr) {
			if (negators.contains(word)) {
				return word;

			}

		}

		return "";
	}
  
  ------------------------------------------------------------------------
  
  public Map<String, Integer> getSentiment(final String textFilePath) {
		SentimentAnalysis obj = new SentimentAnalysis();
		Map<String, Integer> sentiMap = obj.sentimentPerSentence(FileUtils
				.readInputFileAsString(textFilePath));
		return sentiMap;

	}

	public void analyzeSentimentForDoc(final String textFilePath,
			final String poistiveSentiPath, final String negativeSentiPath) {

		int posOverlapCount = 0, negOverlapCount = 0;

		String content = FileUtils.readInputFileAsString(textFilePath);
		List<String> wordSet = Arrays.asList(content.split(" "));

		for (String string : wordSet) {

			if (positiveSentiDic.contains(string)) {
				posOverlapCount = posOverlapCount + 1;
			} else if (negativeSentiDic.contains(string)) {
				negOverlapCount = negOverlapCount + 1;
			}

		}

//		System.out.println(" positive wordcount====>  " + posOverlapCount
//				+ "\n negative wordCount=====>  " + negOverlapCount);
		if (posOverlapCount > negOverlapCount) {
			System.out.println("positive sentiment");

		} else {
			System.out.println("negative sentiment");

		}

	}

	@Override
	public Map<String, Object> overallDocSentiment(final String content) {

		Map<String, Object> map = new HashMap<String, Object>();
		String sentiment = 
				"";
		Map<String, Integer> sentiMap = this.sentimentPerSentence(content);
		int negCount = 0, posCount = 0, neuCount = 0;
		for (Map.Entry<String, Integer> entry : sentiMap.entrySet()) {
			float value = entry.getValue();
			if (value == 0) {
				neuCount = neuCount + 1;
			} else if (value == 1) {
				posCount = posCount + 1;
			} else if (value == -1) {
				negCount = negCount + 1;
			}
		}

		float posPercent =  Math.round((posCount * 100)
				/ sentiMap.size());

		float negPercent = Math.round ((negCount * 100)
				/ sentiMap.size());

		float neuPercent = Math.round((neuCount * 100)
				/ sentiMap.size());
		
		sentiment=largestOfThree(posPercent,negPercent,neuPercent);
		 
		map.put("sentiment", sentiment);
		map.put("pos_percent", posPercent);
		map.put("neg_percent", negPercent);
		map.put("neu_percent", neuPercent);
	
		System.out.println(map);
		return map;
	}

	
	   public static String largestOfThree(float posPercent, float negPercent, float neuPercent) {
	     String sentiment="";
		   if (posPercent > negPercent && posPercent > neuPercent) {
	            sentiment= "positive";
	        } else if (negPercent > posPercent && negPercent > neuPercent) {
	            sentiment= "negative";
	        } else if (neuPercent > posPercent && neuPercent > negPercent ) {
	            sentiment= "neutral";
	        }else if(posPercent==negPercent){
	        	  sentiment= "neutral";
	        }else if(posPercent==neuPercent){
	        	  sentiment= "positive";
	        }else if(negPercent==neuPercent){
	        	  sentiment= "positive";
	        }
	        return sentiment;
	    }
	
	@Override
	public Map<String, Integer> sentimentPerSentence(final String content) {

		int positive = 1, negative = -1, neutral = 0;
		Map<String, Integer> sentiMap = new HashMap<String, Integer>();

		if (content != null && content.length() > 0) {
			Annotation annotation = pipeline.process(content);

			for (CoreMap sentence : annotation
					.get(CoreAnnotations.SentencesAnnotation.class)) {

				int positiveWordPerSentence = 0, negativeWordPerSentence = 0;
				String negatorWord = "";
				String sentenceStr = sentence.toString();

				List<CoreLabel> tokens = sentence.get(TokensAnnotation.class);
				List<String> tokenStr = FileUtils
						.convertCoreLabelToString(tokens);

				if (!ConditionCheck.matchNegators(tokenStr, negator).isEmpty()) { 

					negatorWord = ConditionCheck.matchNegators(tokenStr,
							negator);
					
					String word="";
					if((tokenStr.indexOf(negatorWord)+1)<tokenStr.size())
					 word = tokenStr.get(tokenStr.indexOf(negatorWord) + 1);
					
					if(word.trim().isEmpty()){
						
						sentiMap.put(sentenceStr, negative);
					} else if (word.equalsIgnoreCase("only")) {

							for (int j = tokenStr.indexOf("only") + 1; j < tokens
									.size(); j++) {
								String tag = tokens.get(j).tag();
								word = tokenStr.get(j);
								if (ConditionCheck.matchPosTag(tag)) {
									if (positiveSentiDic.contains(word)) {

										sentiMap.put(sentenceStr, positive);
										break;

									} else if (negativeSentiDic.contains(word)) {

										sentiMap.put(sentenceStr, negative);
										break;

									}
								}
							}

						}	else {

						for (int j = tokenStr.indexOf(negatorWord) + 1; j < tokens
								.size(); j++) {
							String tag = tokens.get(j).tag();

							if (ConditionCheck.matchPosTag(tag)) {

								if (positiveSentiDic.contains(word)) {

									sentiMap.put(sentenceStr, negative);
									break;

								} else if (negativeSentiDic.contains(word)) {

									sentiMap.put(sentenceStr, positive);
									break;

								} else {
									sentiMap.put(sentenceStr, neutral);
								}

							}
						}

					}
				} else {

					for (int i = 0; i < tokens.size(); i++) {

						String word = tokenStr.get(i);
						if (positiveSentiDic.contains(word)) {
							positiveWordPerSentence = positiveWordPerSentence + 1;
						} else if (negativeSentiDic.contains(word)) {
							negativeWordPerSentence = negativeWordPerSentence + 1;
						}
					}

					if (positiveWordPerSentence == negativeWordPerSentence) {

						sentiMap.put(sentenceStr, neutral);

					} else if (positiveWordPerSentence > negativeWordPerSentence) {

						sentiMap.put(sentenceStr, positive);

					} else {
						sentiMap.put(sentenceStr, negative);
					}
				}

			}
		}
		System.out.println(sentiMap);
		return sentiMap;

	}
------------------------------------------------------------------------------------------------------















---------------------------------------------------------------------------------------

private static final int	BUFFER_SIZE	= 2 << 13;

	public static final char[]	_readBuffer	= new char[BUFFER_SIZE];

	/**
	 * <p>
	 * Reads content from an URL into a string buffer.
	 * </p>
	 * 
	 * @param url
	 *            the url to get the content from.
	 * @return string buffer with the contents of the file.
	 */
	public static StringBuilder getContent(final URL url) throws IOException {
		final StringBuilder buffer = new StringBuilder(BUFFER_SIZE);
		InputStreamReader reader = null;
		try {
			reader = new InputStreamReader(url.openStream());
			for (int numRead = 0; numRead >= 0;) {
				int offset = 0;
				for (; offset < _readBuffer.length
						&& (numRead = reader.read(_readBuffer, offset,
								_readBuffer.length - offset)) >= 0; offset += numRead) {
					;
				}
				buffer.append(_readBuffer, 0, offset);

			}
		} finally {
			if (reader != null) {
				reader.close();
			}
		}
		buffer.trimToSize();
		return buffer;
	}

	public static String readInputFileAsString(final String filePath) {
		BufferedReader br = null;
		StringBuilder sb = null;
		try {
			br = new BufferedReader(new FileReader(filePath));
			sb = new StringBuilder();
			String line = br.readLine();

			while (line != null) {
				sb.append(line);
				sb.append("\n");
				line = br.readLine();
			}

		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				br.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return sb.toString();
	}


	
	public static  HashSet<String> convertTextToHashSet(final String filePath) {

		BufferedReader in = null;
		HashSet<String> wordsSet = new HashSet<String>();
		try {
		//	in = new BufferedReader(new FileReader(new File(filePath)));
			in=new BufferedReader(new InputStreamReader(ParamConfiguration.getInstance().getInputStreamFromFile(filePath)));
			String str;
			while ((str = in.readLine()) != null) {
				wordsSet.add(str.toLowerCase());
			}

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (in != null) {
				try {
					in.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

		// System.out.println(wordsSet);
		return wordsSet;
	}

	public static List<String> convertCoreLabelToString(
			final List<CoreLabel> tokens) {
		

		List<String> tokenStr = new ArrayList<String>();
		for (int i = 0; i < tokens.size(); i++) {

			String word = tokens.get(i).originalText();
			tokenStr.add(word.toLowerCase());
		}
		return tokenStr;

	}

-----------------------------------------------------------------------------
https://blog.openshift.com/day-20-stanford-corenlp-performing-sentiment-analysis-of-twitter-using-java/


     ConfigurationBuilder cb = new ConfigurationBuilder();
        cb.setDebugEnabled(true).setOAuthConsumerKey(System.getenv("TWITTER_OAUTH_CONSUMER_KEY"))
                .setOAuthConsumerSecret(System.getenv("TWITTER_OAUTH_CONSUMER_SECRET"))
                .setOAuthAccessToken(System.getenv("TWITTER_OAUTH_ACCESS_TOKEN"))
                .setOAuthAccessTokenSecret(System.getenv("TWITTER_OAUTH_ACCESS_TOKEN_SECRET"));
        TwitterFactory tf = new TwitterFactory(cb.build());
        Twitter twitter = tf.getInstance();
        Query query = new Query(keyword + " -filter:retweets -filter:links -filter:replies -filter:images");
        query.setCount(20);
        query.setLocale("en");
        query.setLang("en");;
        try {
            QueryResult queryResult = twitter.search(query);
            return queryResult.getTweets();
        } catch (TwitterException e) {
            // ignore
            e.printStackTrace();
        }
        return Collections.emptyList();
 
    }
 
